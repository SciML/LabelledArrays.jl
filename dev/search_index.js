var documenterSearchIndex = {"docs":
[{"location":"Example_dsl/#Example:-Nice-DiffEq-Syntax-Without-A-DSL","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"","category":"section"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"Users of the SciML ecosystem are often solving large models with complicated states and hundreds or thousands of parameters. These models are implemented using arrays, and those arrays have traditionally been indexed by integers, such as p[1] or p[1:5]. Numerical indexing is wonderful for small models, but can quickly cause problems as models become bigger. It is easy to forget which index corresponds to which reaction rate or which diffusion coefficient. This confusion can lead to difficult to debug problems in a user's code. LabelledArrays can make an important difference here. It is much easier to build a model using parameter references such as p.rate_nacl or p.probability_birth, instead of p[26] or p[1026]. Labelled arrays make both the development and debugging of models much faster.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"LabelledArrays.jl are a way to get DSL-like syntax without a macro. In this case, we can solve differential equations with labelled components by making use of labelled arrays, and always refer to the components by name instead of index.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"One key caveat is that users do not need to sacrifice performance when using labelled arrays. Labelled arrays are as performant as traditional numerically indexed arrays.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"Let's solve the Lorenz equation using an LVectors. LVectors are mutable. Hence, we can use the non-allocating form of the OrdinaryDiffEq API.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"using LabelledArrays, OrdinaryDiffEq\n\nfunction lorenz_f!(du, u, p, t)\n    du.x = p.σ * (u.y - u.x)\n    du.y = u.x * (p.ρ - u.z) - u.y\n    du.z = u.x * u.y - p.β * u.z\nend\n\nu0 = @LArray [1.0, 0.0, 0.0] (:x, :y, :z)\np = @LArray [10.0, 28.0, 8 / 3] (:σ, :ρ, :β)\ntspan = (0.0, 10.0)\nprob = ODEProblem(lorenz_f!, u0, tspan, p)\nsol = solve(prob, Tsit5())\n# Now the solution can be indexed as .x/y/z as well!\nsol[10].x","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"In the example above, we used an LArray to define the initial state u0 as well as the parameter vector p. The remainder of the ODE solution steps are no different that the original DifferentialEquations tutorials.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"Alternatively, we can use an immutable SLVector to implement the same equation. In this case, we need to use the allocating form of the OrdinaryDiffEq API when defining our model equation.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"LorenzVector = @SLVector (:x, :y, :z)\nLorenzParameterVector = @SLVector (:σ, :ρ, :β)\n\nfunction f(u, p, t)\n    x = p.σ * (u.y - u.x)\n    y = u.x * (p.ρ - u.z) - u.y\n    z = u.x * u.y - p.β * u.z\n    LorenzVector(x, y, z)\nend\n\nu0 = LorenzVector(1.0, 0.0, 0.0)\np = LorenzParameterVector(10.0, 28.0, 8 / 3)\ntspan = (0.0, 10.0)\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5())","category":"page"},{"location":"Note_labelled_slices/#Note:-Labelled-slices","page":"Note: Labelled slices","title":"Note: Labelled slices","text":"","category":"section"},{"location":"Note_labelled_slices/","page":"Note: Labelled slices","title":"Note: Labelled slices","text":"This functionality has been removed from LabelledArrays.jl, but can be replicated with the same compile-time performance and indexing syntax using DimensionalData.jl.","category":"page"},{"location":"LArrays/#LArrays","page":"LArrays","title":"LArrays","text":"","category":"section"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"LArrays are fully mutable arrays with labels. There is no performance loss by using labelled indexing instead of purely numerical indexing. Using the macro with values and labels generates the labelled array with the given values:","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"Users interested in using labelled elements in their arrays should also consider ComponentArrays from the ComponentArrays.jl library. ComponentArrays are well integrated into the SciML ecosystem.","category":"page"},{"location":"LArrays/#@LArray-and-@LVector-macros","page":"LArrays","title":"@LArray and @LVector macros","text":"","category":"section"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"Macro constructors are convenient for building most LArray objects. An @LArray may be of arbitrary dimension, while an @LVector is a one dimensional array.","category":"page"},{"location":"LArrays/#LabelledArrays.@LArray","page":"LArrays","title":"LabelledArrays.@LArray","text":"@LArray Eltype Size Names\n@LArray Values Names\n\nThe @LArray macro creates an LArray with names determined from the Names vector and values determined from the Values vector. Otherwise, the eltype and size are used to make an LArray with undefined values.\n\nA = @LArray [1, 2, 3] (:a, :b, :c)\nA.a == 1\n\nUsers can also generate a labelled array with undefined values by instead giving the dimensions. This approach is useful if the user intends to pre-allocate an array for some later input.\n\nA = @LArray Float64 (2, 2) (:a, :b, :c, :d)\nW = rand(2, 2)\nA .= W\nA.d == W[2, 2]\n\nUsers may also use an alternative constructor to set the Names and Values and ranges at the same time.\n\njulia> z = @LArray [1.0, 2.0, 3.0] (a = 1:2, b = 2:3);\n\njulia> z.b\n2-element view(::Array{Float64,1}, 2:3) with eltype Float64:\n 2.0\n 3.0\n\njulia> z = @LArray [1 2; 3 4] (a = (2, :), b = 2:3);\n\njulia> z.a\n2-element view(::Array{Int64,2}, 2, :) with eltype Int64:\n 3\n 4\n\nThe labels of LArray and SLArray can be accessed by function symbols, which returns a tuple of symbols.\n\n\n\n\n\n","category":"macro"},{"location":"LArrays/#LabelledArrays.@LVector","page":"LArrays","title":"LabelledArrays.@LVector","text":"@LVector Type Names\n\nThe @LVector macro creates an LArray of dimension 1 with eltype and undefined values. The vector's length is equal to the number of names given.\n\nAs with an LArray, the user can initialize the vector and set its values later.\n\nA = @LVector Float64 (:a, :b, :c, :d)\nA .= rand(4)\n\nTo initialize the vector and set its values at the same time, use @LArray instead:\n\nb = @LArray [1, 2, 3] (:a, :b, :c)\n\n\n\n\n\n","category":"macro"},{"location":"LArrays/#LArray-and-LVector-constructors","page":"LArrays","title":"LArray and LVector constructors","text":"","category":"section"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"The original constructors for LArrays and LVectors are as follows:","category":"page"},{"location":"LArrays/#LabelledArrays.LArray","page":"LArrays","title":"LabelledArrays.LArray","text":"LArray(::Tuple, ::NamedTuple)\nLArray(::Tuple, kwargs)\n\nThe standard constructors for LArray.\n\nFor example:\n\nLArray((2, 2), (a = 1, b = 2, c = 3, d = 4))  # need to specify size\nLArray((2, 2); a = 1, b = 2, c = 3, d = 4)\n\n\n\n\n\nLVector(v1::Union{SLArray,LArray}; kwargs...)\n\nCreates a copy of v1 with corresponding items in kwargs replaced.\n\nFor example:\n\nABCD = @SLArray (2,2) (:a,:b,:c,:d);\nB = ABCD(1,2,3,4);\nB2 = LArray(B; c=30 )\n\n\n\n\n\n","category":"type"},{"location":"LArrays/#LabelledArrays.LVector","page":"LArrays","title":"LabelledArrays.LVector","text":"LVector(::NamedTuple)\nLVector(kwargs)\n\nThe standard constructor for LVector.\n\nFor example:\n\nLVector((a = 1, b = 2))\nLVector(a = 1, b = 2)\n\n\n\n\n\nLVector(v1::Union{SLArray,LArray}; kwargs...)\n\nCreates a 1D copy of v1 with corresponding items in kwargs replaced.\n\nFor example:\n\nz = LVector(a=1, b=2, c=3);\nz2 = LVector(z; c=30)\n\n\n\n\n\n","category":"function"},{"location":"LArrays/#Manipulating-LArrays-and-LVectors","page":"LArrays","title":"Manipulating LArrays and LVectors","text":"","category":"section"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"User may want a list of the labels or keys in an LArray or LVector. The symbols(::LArray) function returns a tuple of array labels.","category":"page"},{"location":"LArrays/#LabelledArrays.symbols","page":"LArrays","title":"LabelledArrays.symbols","text":"symbols(::SLArray)\n\nReturns the labels of the SLArray.\n\nFor example:\n\njulia> z = SLVector(a = 1, b = 2, c = 3)\n3-element SLArray{Tuple{3}, Int64, 1, 3, (:a, :b, :c)} with indices SOneTo(3):\n :a => 1\n :b => 2\n :c => 3\n\njulia> symbols(z)\n(:a, :b, :c)\n\n\n\n\n\nsymbols(::LArray)\n\nReturns the labels of the LArray.\n\nFor example:\n\njulia> z = @LVector Float64 (:a, :b, :c, :d);\n\njulia> symbols(z)\n(:a, :b, :c, :d)\n\n\n\n\n\n","category":"function"},{"location":"SLArrays/#SLArrays","page":"SLArrays","title":"SLArrays","text":"","category":"section"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"The SLArray and SLVector macros create static LabelledArrays. First, the user would create the array type, then use that constructor to generate instances of the labelled array.","category":"page"},{"location":"SLArrays/#@SLArray-and-@SLVector-macros","page":"SLArrays","title":"@SLArray and @SLVector macros","text":"","category":"section"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Macro constructors are convenient for building most SLArray objects. An @SLArray may be of arbitrary dimension, while an @SLVector is a one dimensional array.","category":"page"},{"location":"SLArrays/#LabelledArrays.@SLArray","page":"SLArrays","title":"LabelledArrays.@SLArray","text":"@SLArray Size Names\n@SLArray Eltype Size Names\n\nThe macro creates a labelled static vector with element type ElType, names from Names, and size from Size. If no eltype is given, then the eltype is determined from the arguments in the constructor.\n\nFor example:\n\nABCD = @SLArray (2, 2) (:a, :b, :c, :d)\nx = ABCD(1.0, 2.5, 3.0, 5.0)\nx.a == 1.0\nx.b == 2.5\nx.c == x[3]\nx.d == x[2, 2]\nEFG = @SLArray (2, 2) (e = 1:3, f = 4, g = 2:4)\ny = EFG(1.0, 2.5, 3.0, 5.0)\nEFG = @SLArray (2, 2) (e = (2, :), f = 4, g = 2:4)\n\nUsers can also specify the indices directly.\n\njulia> EFG = @SLArray (2, 2) (e = 1:3, f = 4, g = 2:4);\n\njulia> y = EFG(1.0, 2.5, 3.0, 5.0)\n2×2 SLArray{Tuple{2,2},Float64,2,4,(e = 1:3, f = 4, g = 2:4)}:\n 1.0  3.0\n 2.5  5.0\n\njulia> y.g\n3-element view(reshape(::StaticArrays.SArray{Tuple{2,2},Float64,2,4}, 4), 2:4) with eltype Float64:\n 2.5\n 3.0\n 5.0\n\njulia> Arr = @SLArray (2, 2) (a = (2, :), b = 3);\n\njulia> z = Arr(1, 2, 3, 4);\n\njulia> z.a\n2-element view(::StaticArrays.SArray{Tuple{2,2},Int64,2,4}, 2, :) with eltype Int64:\n 2\n 4\n\n\n\n\n\n","category":"macro"},{"location":"SLArrays/#LabelledArrays.@SLVector","page":"SLArrays","title":"LabelledArrays.@SLVector","text":"@SLVector Names\n@SLVector Eltype Names\n\nThe macro creates a labelled static vector with element type ElType, and names from Names. If no eltype is given, then the eltype is determined from the values in the constructor. The array size is found from the input data.\n\nFor example:\n\nABC = @SLVector (:a, :b, :c)\nx = ABC(1.0, 2.5, 3.0)\nx.a == 1.0\nx.b == 2.5\nx.c == x[3]\n\n\n\n\n\n","category":"macro"},{"location":"SLArrays/#SLArray-and-SLVector-constructors","page":"SLArrays","title":"SLArray and SLVector constructors","text":"","category":"section"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Alternatively, users can construct a static labelled array using the SLVector and SLArrays constructors by writing out the entries as keyword arguments:","category":"page"},{"location":"SLArrays/#LabelledArrays.SLArray","page":"SLArrays","title":"LabelledArrays.SLArray","text":"SLArray{::Tuple}(::NamedTuple)\nSLArray{::Tuple}(kwargs)\n\nThese are the standard constructors for SLArray. For general N-dimensional labelled arrays, users need to specify the size (Tuple{dim1,dim2,...}) in the type parameter to the SLArray constructor:\n\njulia> SLArray{Tuple{2, 2}}((a = 1, b = 2, c = 3, d = 4))\n2×2 SLArray{Tuple{2, 2}, Int64, 2, 4, (:a, :b, :c, :d)} with indices SOneTo(2)×SOneTo(2):\n :a => 1  :c => 3\n :b => 2  :d => 4\n\njulia> SLArray{Tuple{2, 2}}(a = 1, b = 2, c = 3, d = 4)\n 2×2 SLArray{Tuple{2,2},2,(:a, :b, :c, :d),Int64}:\n 1  3\n 2  4\n\nConstructing copies with some changed elements is supported by a keyword constructor whose first argument is the source and whose additional keyword arguments indicate the changes.\n\njulia> ABCD = @SLArray (2, 2) (:a, :b, :c, :d);\n\njulia> B = ABCD(1, 2, 3, 4);\n\njulia> B2 = SLArray(B; c = 30)\n2×2 SLArray{Tuple{2,2},Int64,2,4,(:a, :b, :c, :d)}:\n 1  30\n 2   4\n\nAdditional examples:\n\nSLArray{Tuple{2, 2}}((a = 1, b = 2, c = 3, d = 4))\n\n\n\n\n\nSLVector(v1::SLArray; kwargs...)\n\nCreates a copy of v1 with corresponding items in kwargs replaced.\n\nFor example:\n\nABCD = @SLArray (2,2) (:a,:b,:c,:d);\nB = ABCD(1,2,3,4);\nB2 = SLArray(B; c=30 )\n\n\n\n\n\n","category":"type"},{"location":"SLArrays/#LabelledArrays.SLVector","page":"SLArrays","title":"LabelledArrays.SLVector","text":"SLVector(::NamedTuple)\nSLVector(kwargs)\n\nThe standard constructors for SLArray.\n\njulia> SLVector(a = 1, b = 2, c = 3)\n3-element SLArray{Tuple{3},1,(:a, :b, :c),Int64}:\n 1\n 2\n 3\n\nConstructing copies with some items changed is supported by a keyword constructor whose first argument is the source and whose additional keyword arguments indicate the changes.\n\njulia> v1 = SLVector(a = 1.1, b = 2.2, c = 3.3);\n\njulia> v2 = SLVector(v1; b = 20.20, c = 30.30)\n3-element SLArray{Tuple{3},Float64,1,3,(:a, :b, :c)}:\n  1.1\n 20.2\n 30.3\n\nAdditional examples:\n\nSLVector((a = 1, b = 2))\nSLVector(a = 1, b = 2)\n\n\n\n\n\nSLVector(v1::SLArray; kwargs...)\n\nCreates a 1D copy of v1 with corresponding items in kwargs replaced.\n\nFor example:\n\nz = SLVector(a=1, b=2, c=3);\nz2 = SLVector(z; c=30)\n\n\n\n\n\n","category":"function"},{"location":"SLArrays/#Manipulating-SLArrays-and-SLVectors","page":"SLArrays","title":"Manipulating SLArrays and SLVectors","text":"","category":"section"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Users may want a list of the labels or keys in an SLArray or SLVector. The symbols(::SLArray) function returns a tuple of array labels.","category":"page"},{"location":"SLArrays/#LabelledArrays.symbols-Tuple{SLArray}","page":"SLArrays","title":"LabelledArrays.symbols","text":"symbols(::SLArray)\n\nReturns the labels of the SLArray.\n\nFor example:\n\njulia> z = SLVector(a = 1, b = 2, c = 3)\n3-element SLArray{Tuple{3}, Int64, 1, 3, (:a, :b, :c)} with indices SOneTo(3):\n :a => 1\n :b => 2\n :c => 3\n\njulia> symbols(z)\n(:a, :b, :c)\n\n\n\n\n\nsymbols(::LArray)\n\nReturns the labels of the LArray.\n\nFor example:\n\njulia> z = @LVector Float64 (:a, :b, :c, :d);\n\njulia> symbols(z)\n(:a, :b, :c, :d)\n\n\n\n\n\n","category":"method"},{"location":"NamedTuples_relation/#Relation-to-NamedTuples","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"","category":"section"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"Julia's Base has NamedTuples in v0.7+. They are constructed as:","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"p = (σ = 10.0, ρ = 28.0, β = 8 / 3)","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"and they support p[1] and p.σ as well. The LVector, SLVector, LArray and SLArray constructors also support named tuples as their arguments:","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"julia> LVector((a = 1, b = 2))\n2-element LArray{Int64,1,(:a, :b)}:\n 1\n 2\n\njulia> SLVector((a = 1, b = 2))\n2-element SLArray{Tuple{2},1,(:a, :b),Int64}:\n 1\n 2\n\njulia> LArray((2, 2), (a = 1, b = 2, c = 3, d = 4))\n2×2 LArray{Int64,2,(:a, :b, :c, :d)}:\n 1  3\n 2  4\n\njulia> SLArray{Tuple{2, 2}}((a = 1, b = 2, c = 3, d = 4))\n2×2 SLArray{Tuple{2,2},2,(:a, :b, :c, :d),Int64}:\n 1  3\n 2  4","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"Converting to a named tuple from a labelled array x is available using convert(NamedTuple, x). Furthermore, pairs(x) creates an iterator that is functionally the same as pairs(convert(NamedTuple, x)), yielding :label => x.label for each label of the array.","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"There are some crucial differences between a labelled array and a named tuple. Labelled arrays can have any dimensions, while named tuples are always 1D. A named tuple can have different types on each element, while an SLArray can only have one element type and furthermore it has the actions of a static vector. As a result SLArray has less element type information, which improves compilation speed while giving more vector functionality than a NamedTuple. LArray also only has a single element type and, unlike a named tuple, is mutable.","category":"page"},{"location":"#LabelledArrays.jl:-Arrays-with-Label-Goodness","page":"Home","title":"LabelledArrays.jl: Arrays with Label Goodness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LabelledArrays.jl is a package which provides arrays with labels, i.e. they are arrays which map, broadcast, and all of that good stuff, but their components are labelled. For instance, users can name the second component of an array to :second and retrieve it with A.second.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install LabelledArrays.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"LabelledArrays\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
