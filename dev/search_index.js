var documenterSearchIndex = {"docs":
[{"location":"Example_dsl/#Example:-Nice-DiffEq-Syntax-Without-A-DSL","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"","category":"section"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"LabelledArrays.jl are a way to get DSL-like syntax without a macro. In this case, we can solve differential equations with labelled components by making use of labelled arrays, and always refer to the components by name instead of index.","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"Let's solve the Lorenz equation. Using @LVectors, we can do:","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"using LabelledArrays, OrdinaryDiffEq\n\nfunction lorenz_f(du,u,p,t)\n  du.x = p.σ*(u.y-u.x)\n  du.y = u.x*(p.ρ-u.z) - u.y\n  du.z = u.x*u.y - p.β*u.z\nend\n\nu0 = @LArray [1.0,0.0,0.0] (:x,:y,:z)\np = @LArray [10.0, 28.0, 8/3]  (:σ,:ρ,:β)\ntspan = (0.0,10.0)\nprob = ODEProblem(lorenz_f,u0,tspan,p)\nsol = solve(prob,Tsit5())\n# Now the solution can be indexed as .x/y/z as well!\nsol[10].x","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"We can also make use of @SLVector:","category":"page"},{"location":"Example_dsl/","page":"Example: Nice DiffEq Syntax Without A DSL","title":"Example: Nice DiffEq Syntax Without A DSL","text":"LorenzVector = @SLVector (:x,:y,:z)\nLorenzParameterVector = @SLVector (:σ,:ρ,:β)\n\nfunction f(u,p,t)\n  x = p.σ*(u.y-u.x)\n  y = u.x*(p.ρ-u.z) - u.y\n  z = u.x*u.y - p.β*u.z\n  LorenzVector(x,y,z)\nend\n\nu0 = LorenzVector(1.0,0.0,0.0)\np = LorenzParameterVector(10.0,28.0,8/3)\ntspan = (0.0,10.0)\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"Note_labelled_slices/#Note:-Labelled-slices","page":"Note: Labelled slices","title":"Note: Labelled slices","text":"","category":"section"},{"location":"Note_labelled_slices/","page":"Note: Labelled slices","title":"Note: Labelled slices","text":"This functionality has been removed from LabelledArrays.jl, but can  replicated with the same compile-time performance and indexing syntax  using DimensionalData.jl.","category":"page"},{"location":"LArrays/#LArrays","page":"LArrays","title":"LArrays","text":"","category":"section"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"The LArrayss are fully mutable arrays with labels. There is no performance loss by using the labelled instead of indexing. Using the macro with values and labels generates the labelled array with the given values:","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"A = @LArray [1,2,3] (:a,:b,:c)\nA.a == 1","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"One can generate a labelled array with undefined values by instead giving the dimensions:","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"A = @LArray Float64 (2,2) (:a,:b,:c,:d)\nW = rand(2,2)\nA .= W\nA.d == W[2,2]","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"or using an @LVector shorthand:","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"A = @LVector Float64 (:a,:b,:c,:d)\nA .= rand(4)","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"As with SLArray, alternative constructors exist that use the keyword argument form:","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"julia> LVector(a=1, b=2, c=3)\n3-element LArray{Int64,1,(:a, :b, :c)}:\n 1\n 2\n 3\n\njulia> LArray((2,2); a=1, b=2, c=3, d=4) # need to specify size as first argument\n2×2 LArray{Int64,2,(:a, :b, :c, :d)}:\n 1  3\n 2  4","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"One can also specify the indices directly.","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"julia> z = @LArray [1.,2.,3.] (a = 1:2, b = 2:3);\njulia> z.b\n2-element view(::Array{Float64,1}, 2:3) with eltype Float64:\n 2.0\n 3.0\njulia> z = @LArray [1 2; 3 4] (a = (2, :), b = 2:3);\njulia> z.a\n2-element view(::Array{Int64,2}, 2, :) with eltype Int64:\n 3\n 4","category":"page"},{"location":"LArrays/","page":"LArrays","title":"LArrays","text":"The labels of LArray and SLArray can be accessed  by function symbols, which returns a tuple of symbols.","category":"page"},{"location":"SLArrays/#SLArrays","page":"SLArrays","title":"SLArrays","text":"","category":"section"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"The SLArray and SLVector macros are for creating static LabelledArrays. First you create the type and then you can use that constructor to generate instances of the labelled array.","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"ABC = @SLVector (:a,:b,:c)\nA = ABC(1,2,3)\nA.a == 1\n\nABCD = @SLArray (2,2) (:a,:b,:c,:d)\nB = ABCD(1,2,3,4)\nB.c == 3\nB[2,2] == B.d","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Here we have that A == [1,2,3] and for example A.b == 2. We can create a typed SLArray via:","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"SVType = @SLVector Float64 (:a,:b,:c)","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Alternatively, you can also construct a static labelled array using the SLVector constructor by writing out the entries as keyword arguments:","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"julia> SLVector(a=1, b=2, c=3)\n3-element SLArray{Tuple{3},1,(:a, :b, :c),Int64}:\n 1\n 2\n 3","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"For general N-dimensional labelled arrays, you need to specify the size (Tuple{dim1,dim2,...}) as the type parameter to the SLArray constructor:","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"julia> SLArray{Tuple{2,2}}(a=1, b=2, c=3, d=4)\n2×2 SLArray{Tuple{2,2},2,(:a, :b, :c, :d),Int64}:\n 1  3\n 2  4","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"Constructing copies with some items changed is supported by a keyword constructor whose first argument is the source and additonal keyword arguments change several entries.","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"julia> v1 = SLVector(a=1.1, b=2.2, c=3.3);\njulia> v2 = SLVector(v1; b=20.20, c=30.30 )\n3-element SLArray{Tuple{3},Float64,1,3,(:a, :b, :c)}:\n  1.1\n 20.2\n 30.3","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"julia> ABCD = @SLArray (2,2) (:a,:b,:c,:d);\njulia> B = ABCD(1,2,3,4);\njulia> B2 = SLArray(B; c=30 )\n2×2 SLArray{Tuple{2,2},Int64,2,4,(:a, :b, :c, :d)}:\n 1  30\n 2   4","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"One can also specify the indices directly.","category":"page"},{"location":"SLArrays/","page":"SLArrays","title":"SLArrays","text":"julia> EFG = @SLArray (2,2) (e=1:3, f=4, g=2:4);\njulia> y = EFG(1.0,2.5,3.0,5.0)\n2×2 SLArray{Tuple{2,2},Float64,2,4,(e = 1:3, f = 4, g = 2:4)}:\n 1.0  3.0\n 2.5  5.0\n\njulia> y.g\n3-element view(reshape(::StaticArrays.SArray{Tuple{2,2},Float64,2,4}, 4), 2:4) with eltype Float64:\n 2.5\n 3.0\n 5.0\n\njulia> Arr = @SLArray (2, 2) (a = (2, :), b = 3);\njulia> z = Arr(1, 2, 3, 4);\njulia> z.a\n2-element view(::StaticArrays.SArray{Tuple{2,2},Int64,2,4}, 2, :) with eltype Int64:\n 2\n 4","category":"page"},{"location":"NamedTuples_relation/#Relation-to-NamedTuples","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"","category":"section"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"Julia's Base has NamedTuples in v0.7+. They are constructed as:","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"p = (σ = 10.0,ρ = 28.0,β = 8/3)","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"and they support p[1] and p.σ as well. The LVector, SLVector, LArray and SLArray constructors also support named tuples as their arguments:","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"julia> LVector((a=1, b=2))\n2-element LArray{Int64,1,(:a, :b)}:\n 1\n 2\n\njulia> SLVector((a=1, b=2))\n2-element SLArray{Tuple{2},1,(:a, :b),Int64}:\n 1\n 2\n\njulia> LArray((2,2), (a=1, b=2, c=3, d=4))\n2×2 LArray{Int64,2,(:a, :b, :c, :d)}:\n 1  3\n 2  4\n\njulia> SLArray{Tuple{2,2}}((a=1, b=2, c=3, d=4))\n2×2 SLArray{Tuple{2,2},2,(:a, :b, :c, :d),Int64}:\n 1  3\n 2  4","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"Converting to a named tuple from a labelled array x is available using convert(NamedTuple, x). Furthermore, pairs(x) creates an iterator that is functionally the same as pairs(convert(NamedTuple, x)), yielding :label => x.label for each label of the array.","category":"page"},{"location":"NamedTuples_relation/","page":"Relation to NamedTuples","title":"Relation to NamedTuples","text":"There are some crucial differences between a labelled array and a named tuple. Labelled arrays can have any dimensions while  named tuples are always 1D. A named tuple can have different types on each element, while an SLArray can only have one element type and furthermore it has the actions of a static vector. As a result SLArray has less element type information, which  improves compilation speed while giving more vector functionality than a NamedTuple. LArray also only has a single element type and, unlike a named tuple, is mutable.","category":"page"},{"location":"#LabelledArrays.jl:-Arrays-with-Label-Goodness","page":"Home","title":"LabelledArrays.jl: Arrays with Label Goodness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LabelledArrays.jl is a package which provides arrays with labels, i.e. they are arrays which map, broadcast, and all of that good stuff, but their components are labelled. Thus for instance you can set that the second component is named :second and retrieve it with A.second.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install LabelledArrays.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"LabelledArrays\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nthe #diffeq-bridged channel in the Julia Slack\nJuliaDiffEq on Gitter\non the Julia Discourse forums\nsee also SciML Community page","category":"page"}]
}
